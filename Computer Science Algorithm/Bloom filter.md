A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not – in other words, a query returns either "possibly in set" or "definitely not in set". Elements can be added to the set, but not removed (though this can be addressed with the counting Bloom filter variant); the more items added, the larger the probability of false positives.
![[Pasted image 20221213103732.png]]
![[Pasted image 20221213103747.png]]
It is a useful to filter request before asking [[Database]] or the system.

## How it works
An empty Bloom filter is a bit [[array]] of m bits, all set to 0. There must also be k different hash functions defined, each of which maps or hashes some set element to one of the m [[array]] positions, generating a uniform random distribution. Typically, k is a small constant which depends on the desired false error rate ε, while m is proportional to k and the number of elements to be added.

To add an element, feed it to each of the k hash functions to get k [[array]] positions. Set the bits at all these positions to 1.

To query for an element (test whether it is in the set), feed it to each of the k [[Hash Function|hash functions]] to get k [[array]] positions. If any of the bits at these positions is 0, the element is definitely not in the set; if it were, then all the bits would have been set to 1 when it was inserted. If all are 1, then either the element is in the set, or the bits have by chance been set to 1 during the insertion of other elements, resulting in a false positive. In a simple Bloom filter, there is no way to distinguish between the two cases, but more advanced techniques can address this problem.

While risking false positives, Bloom filters have a substantial space advantage over other data structures for representing sets, such as [[Self-Balancing Binary Search Trees|self-balancing binary search trees]], tries, [[Hash Table|hash tables]], or simple [[Array|arrays]] or [[Linked List|linked lists]] of the entries. Most of these require storing at least the data items themselves, which can require anywhere from a small number of bits, for small integers, to an arbitrary number of bits, such as for strings (tries are an exception since they can share storage between elements with equal prefixes). However, Bloom filters do not store the data items at all, and a separate solution must be provided for the actual storage. Linked structures incur an additional linear space overhead for pointers. A Bloom filter with a 1% error and an optimal value of k, in contrast, requires only about 9.6 bits per element, regardless of the size of the elements. This advantage comes partly from its compactness, inherited from arrays, and partly from its probabilistic nature. The 1% false-positive rate can be reduced by a factor of ten by adding only about 4.8 bits per element.